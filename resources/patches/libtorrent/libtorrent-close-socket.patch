diff -urN libtorrent-0.16.5.orig/src/net/curl_socket.cc libtorrent-0.16.5/src/net/curl_socket.cc
--- libtorrent-0.16.5.orig/src/net/curl_socket.cc	2025-12-16 18:43:01.434708248 -0600
+++ libtorrent-0.16.5/src/net/curl_socket.cc	2025-12-16 18:43:39.060979391 -0600
@@ -20,11 +20,15 @@
     if (socket == nullptr)
       return 0;
 
-    // We also probably need the special code here as we're not
-    // guaranteed that the fd will be closed, afaik.
-    socket->close();
+    // CURL_CLOSESOCKET_FIX: libcurl is telling us to stop polling this fd.
+    // The CLOSESOCKET callback will perform the actual close.
+    this_thread::poll()->remove_read(socket);
+    this_thread::poll()->remove_write(socket);
+    this_thread::poll()->remove_error(socket);
+
+    // Clear association from libcurl
+    curl_multi_assign(stack->handle(), fd, nullptr);
 
-    delete socket;
     return 0;
   }
 
@@ -36,6 +40,7 @@
     // TODO: Might not be getting removed ? verify fd, etc.
 
     socket = new CurlSocket(fd, stack);
+    stack->track_socket(fd, socket);
     curl_multi_assign(stack->handle(), fd, socket);
 
     this_thread::poll()->open(socket);
@@ -69,9 +74,17 @@
 void
 CurlSocket::close() {
   if (m_fileDesc == -1)
-    throw internal_error("CurlSocket::close() m_fileDesc == -1.");
+    return;
 
-  this_thread::poll()->remove_and_close(this);
+  try {
+    this_thread::poll()->remove_and_close(this);
+  } catch (const internal_error&) {
+    try {
+      this_thread::poll()->remove_read(this);
+      this_thread::poll()->remove_write(this);
+      this_thread::poll()->remove_error(this);
+    } catch (...) {}
+  }
 
   m_stack = nullptr;
   m_fileDesc = -1;
diff -urN libtorrent-0.16.5.orig/src/net/curl_stack.cc libtorrent-0.16.5/src/net/curl_stack.cc
--- libtorrent-0.16.5.orig/src/net/curl_stack.cc	2025-12-16 18:43:01.434708248 -0600
+++ libtorrent-0.16.5/src/net/curl_stack.cc	2025-12-16 18:44:59.617104943 -0600
@@ -29,6 +29,49 @@
   curl_multi_setopt(m_handle, CURLMOPT_MAX_TOTAL_CONNECTIONS, m_max_total_connections);
 }
 
+// CURL_CLOSESOCKET_FIX
+void
+CurlStack::track_socket(curl_socket_t fd, CurlSocket* socket) {
+  std::scoped_lock guard(m_mutex);
+  m_sockets[fd] = socket;
+}
+
+CurlSocket*
+CurlStack::take_socket(curl_socket_t fd) {
+  std::scoped_lock guard(m_mutex);
+  auto itr = m_sockets.find(fd);
+  if (itr == m_sockets.end())
+    return nullptr;
+  auto* socket = itr->second;
+  m_sockets.erase(itr);
+  return socket;
+}
+
+int
+CurlStack::close_socket(void* clientp, curl_socket_t fd) {
+  auto* stack = static_cast<CurlStack*>(clientp);
+  if (!stack)
+    return 0;
+
+  auto* socket = stack->take_socket(fd);
+  if (!socket)
+    return 0;
+
+  try {
+    socket->close();
+  } catch (const torrent::internal_error&) {
+    try {
+      this_thread::poll()->remove_read(socket);
+      this_thread::poll()->remove_write(socket);
+      this_thread::poll()->remove_error(socket);
+    } catch (...) {}
+    socket->m_stack = nullptr;
+    socket->m_fileDesc = -1;
+  }
+  delete socket;
+  return 0;
+}
+
 CurlStack::~CurlStack() {
   assert(!is_running() && "CurlStack::~CurlStack() called while still running.");
 }
@@ -124,6 +167,9 @@
     curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_SSL_VERIFYPEER, m_ssl_verify_peer ? 1l : 0l);
     curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_DNS_CACHE_TIMEOUT, m_dns_timeout);
 
+    curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_CLOSESOCKETFUNCTION, &CurlStack::close_socket);
+    curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_CLOSESOCKETDATA, this);
+
     base_type::push_back(curl_get);
 
     curl_get->activate_unsafe();
diff -urN libtorrent-0.16.5.orig/src/net/curl_stack.h libtorrent-0.16.5/src/net/curl_stack.h
--- libtorrent-0.16.5.orig/src/net/curl_stack.h	2025-12-16 18:43:01.434708248 -0600
+++ libtorrent-0.16.5/src/net/curl_stack.h	2025-12-16 18:44:24.762796162 -0600
@@ -5,6 +5,7 @@
 #include <mutex>
 #include <new>
 #include <string>
+#include <unordered_map>
 #include <vector>
 #include <curl/curl.h>
 
@@ -78,6 +79,10 @@
 
   base_type::iterator find_curl_handle(const CURL* curl_handle);
 
+  void                track_socket(curl_socket_t fd, CurlSocket* socket);
+  CurlSocket*         take_socket(curl_socket_t fd);
+  static int          close_socket(void* clientp, curl_socket_t fd);
+
   static int          set_timeout(void*, long timeout_ms, CurlStack* stack);
 
   void                receive_timeout();
@@ -106,6 +111,8 @@
   bool                m_ssl_verify_host{true};
   bool                m_ssl_verify_peer{true};
   long                m_dns_timeout{60};
+
+  std::unordered_map<curl_socket_t, CurlSocket*> m_sockets;
 };
 
 inline bool
diff -urN libtorrent-0.16.5.orig/src/torrent/net/poll_epoll.cc libtorrent-0.16.5/src/torrent/net/poll_epoll.cc
--- libtorrent-0.16.5.orig/src/torrent/net/poll_epoll.cc	2025-12-16 18:43:01.426708616 -0600
+++ libtorrent-0.16.5/src/torrent/net/poll_epoll.cc	2025-12-16 18:45:27.107782272 -0600
@@ -96,8 +96,9 @@
   set_event_mask(event, mask);
 
   if (epoll_ctl(m_fd, op, event->file_descriptor(), &e)) {
-    // Socket was probably already closed. Ignore this.
-    if (op == EPOLL_CTL_DEL && errno == ENOENT)
+    // EPOLL_FD_RACE_FIX: Socket was probably already closed. Ignore FD errors on delete.
+    // See: https://github.com/rakshasa/libtorrent/issues/622
+    if (op == EPOLL_CTL_DEL && (errno == ENOENT || errno == EBADF || errno == EPERM))
       return;
 
     // Handle some libcurl/c-ares bugs by retrying once.

--- a/src/net/curl_stack.h
+++ b/src/net/curl_stack.h
@@
 #include <memory>
 #include <mutex>
 #include <new>
 #include <string>
 #include <vector>
+#include <unordered_map> // CURL_CLOSESOCKET_FIX
@@
   base_type::iterator find_curl_handle(const CURL* curl_handle);

  void                track_socket(curl_socket_t fd, CurlSocket* socket);             // CURL_CLOSESOCKET_FIX
  CurlSocket*         take_socket(curl_socket_t fd);                                  // CURL_CLOSESOCKET_FIX
  static int          close_socket(void* clientp, curl_socket_t fd);                  // CURL_CLOSESOCKET_FIX

   static int          set_timeout(void*, long timeout_ms, CurlStack* stack);
@@
   bool                m_ssl_verify_host{true};
   bool                m_ssl_verify_peer{true};
   long                m_dns_timeout{60};

  std::unordered_map<curl_socket_t, CurlSocket*> m_sockets;                           // CURL_CLOSESOCKET_FIX
 };
--- a/src/net/curl_stack.cc
+++ b/src/net/curl_stack.cc
@@
 #include "config.h"

 #include "curl_stack.h"

 #include <algorithm>
 #include <cassert>
 #include <curl/multi.h>
+#include "torrent/net/poll.h"

 #include "net/curl_get.h"
 #include "net/curl_socket.h"
 #include "torrent/exceptions.h"
 #include "torrent/utils/thread.h"
@@
   curl_multi_setopt(m_handle, CURLMOPT_TIMERDATA, this);
   curl_multi_setopt(m_handle, CURLMOPT_TIMERFUNCTION, &CurlStack::set_timeout);
   curl_multi_setopt(m_handle, CURLMOPT_SOCKETDATA, this);
   curl_multi_setopt(m_handle, CURLMOPT_SOCKETFUNCTION, &CurlSocket::receive_socket);
@@
   curl_multi_setopt(m_handle, CURLMOPT_MAXCONNECTS, m_max_cache_connections);
   curl_multi_setopt(m_handle, CURLMOPT_MAX_HOST_CONNECTIONS, m_max_host_connections);
   curl_multi_setopt(m_handle, CURLMOPT_MAX_TOTAL_CONNECTIONS, m_max_total_connections);
 }

void
CurlStack::track_socket(curl_socket_t fd, CurlSocket* socket) {
  auto guard = std::scoped_lock(m_mutex);
  m_sockets[fd] = socket;
}

CurlSocket*
CurlStack::take_socket(curl_socket_t fd) {
  auto guard = std::scoped_lock(m_mutex);
  auto itr = m_sockets.find(fd);
  if (itr == m_sockets.end())
    return nullptr;

  auto* socket = itr->second;
  m_sockets.erase(itr);
  return socket;
}

int
CurlStack::close_socket(void* clientp, curl_socket_t fd) {
  auto* stack = static_cast<CurlStack*>(clientp);
  if (stack == nullptr)
    return 0;

  auto* socket = stack->take_socket(fd);
  if (socket == nullptr)
    return 0;

  this_thread::poll()->remove_and_close(socket);
  curl_multi_assign(stack->handle(), fd, nullptr);

  delete socket;
  return 0;
}

@@
     if (!m_http_ca_cert.empty())
       curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_CAINFO, m_http_ca_cert.c_str());

     curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_SSL_VERIFYHOST, m_ssl_verify_host ? 2l : 0l);
     curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_SSL_VERIFYPEER, m_ssl_verify_peer ? 1l : 0l);
     curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_DNS_CACHE_TIMEOUT, m_dns_timeout);

     // Ensure libcurl notifies us before it closes or reuses sockets so we can unregister from poll.
     curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_CLOSESOCKETFUNCTION, &CurlStack::close_socket); // CURL_CLOSESOCKET_FIX
     curl_easy_setopt(curl_get->handle_unsafe(), CURLOPT_CLOSESOCKETDATA, this);
--- a/src/net/curl_socket.cc
+++ b/src/net/curl_socket.cc
@@
   if (what == CURL_POLL_REMOVE) {
     if (socket == nullptr)
       return 0;

     // We also probably need the special code here as we're not
     // guaranteed that the fd will be closed, afaik.
    auto* tracked = stack->take_socket(fd); // CURL_CLOSESOCKET_FIX
    if (tracked == nullptr)
      return 0;

    this_thread::poll()->remove_and_close(tracked);

    // Clear association from libcurl to avoid reuse after close.
    curl_multi_assign(stack->handle(), fd, nullptr);

    delete tracked;
     return 0;
   }
@@

     socket = new CurlSocket(fd, stack);
     curl_multi_assign(stack->handle(), fd, socket);
     stack->track_socket(fd, socket); // CURL_CLOSESOCKET_FIX

     this_thread::poll()->open(socket);
     this_thread::poll()->insert_error(socket);
   }